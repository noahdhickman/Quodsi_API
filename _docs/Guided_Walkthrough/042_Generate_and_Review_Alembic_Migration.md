# Step 3: Generate and Review Alembic Migration

## 3.1 Generate Migration
```bash
# Generate the first real migration for tenants table
alembic revision --autogenerate -m "create tenants table"
```

## 3.2 Review Generated Migration
Open the generated migration file in `alembic/versions/` and verify:

1. **Table Creation**: `tenants` table with all BaseEntity fields
2. **Indexes**: Clustered and filtered indexes from BaseEntity
3. **Constraints**: Unique constraints on subdomain and slug
4. **Data Types**: Proper SQL Server types (UNIQUEIDENTIFIER, BIGINT, etc.)

**⚠️ Important SQL Server Fix Required:**
Alembic's auto-generation may not properly handle the non-clustered primary key. You'll need to manually edit the migration file:

**Find this line:**
```python
sa.PrimaryKeyConstraint('id'),
```

**Change it to:**
```python
sa.PrimaryKeyConstraint('id', mssql_clustered=False),
```

**Why:** SQL Server creates clustered primary keys by default, but we want `index_id` to be the clustered index for performance. This manual edit ensures the primary key is non-clustered.

**Note:** This manual edit will be required for most migrations when using BaseEntity with SQL Server. This is normal and expected behavior.

**⚠️ Critical: Missing Indexes Issue**
Alembic's auto-generation often misses complex SQL Server-specific indexes defined in BaseEntity's `__table_args__`. You must manually add these critical indexes:

**Add these indexes after the table creation in the `upgrade()` function:**
```python
# Critical missing indexes from BaseEntity - manually added
# Clustered index on index_id for optimal insert performance  
op.create_index(
    'ix_tenants_index_id',
    'tenants', 
    ['index_id'],
    unique=True,
    mssql_clustered=True
)

# Filtered index for active tenants (most common query pattern)
op.create_index(
    'ix_tenants_active',
    'tenants',
    ['is_deleted'], 
    mssql_where='is_deleted = 0'
)
```

**Add corresponding drops in the `downgrade()` function:**
```python
# Drop manually added indexes first
op.drop_index('ix_tenants_active', table_name='tenants')
op.drop_index('ix_tenants_index_id', table_name='tenants')
```

**Why these indexes are critical:**
- **Clustered index on `index_id`**: Essential for optimal insert performance (auto-incrementing key)
- **Filtered index on `is_deleted = 0`**: Optimizes the most common query pattern (active records)
- **Without these**: Performance will be significantly degraded, especially with large datasets

**Expected migration structure:**
```python
def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('tenants',
        sa.Column('id', mssql.UNIQUEIDENTIFIER(), nullable=False),
        sa.Column('index_id', sa.BigInteger(), nullable=False),
        sa.Column('tenant_id', mssql.UNIQUEIDENTIFIER(), nullable=True),
        sa.Column('created_at', sa.DateTime(), nullable=False),
        sa.Column('updated_at', sa.DateTime(), nullable=False),
        sa.Column('is_deleted', sa.Boolean(), nullable=False),
        sa.Column('name', sa.String(length=255), nullable=False),
        sa.Column('subdomain', sa.String(length=100), nullable=False),
        sa.Column('slug', sa.String(length=100), nullable=False),
        sa.Column('plan_type', sa.String(length=50), nullable=False),
        sa.Column('status', sa.String(length=20), nullable=False),
        sa.Column('max_users', sa.Integer(), nullable=False),
        sa.Column('max_models', sa.Integer(), nullable=False),
        sa.Column('max_scenarios_per_month', sa.Integer(), nullable=False),
        sa.Column('max_storage_gb', sa.DECIMAL(precision=10, scale=2), nullable=False),
        sa.Column('trial_expires_at', sa.DateTime(), nullable=True),
        sa.Column('activated_at', sa.DateTime(), nullable=True),
        sa.Column('stripe_customer_id', sa.String(length=255), nullable=True),
        sa.Column('billing_email', sa.String(length=255), nullable=True),
        sa.PrimaryKeyConstraint('id', mssql_clustered=False),
        sa.UniqueConstraint('slug', name='uq_tenants_slug'),
        sa.UniqueConstraint('subdomain', name='uq_tenants_subdomain')
    )
    # Indexes will be listed here...
```

## 3.3 Manual Migration Adjustments (if needed)
You may need to add or adjust:

```python
# Add after table creation
# Ensure proper defaults
op.execute("ALTER TABLE tenants ADD CONSTRAINT df_tenants_plan_type DEFAULT 'trial' FOR plan_type")
op.execute("ALTER TABLE tenants ADD CONSTRAINT df_tenants_status DEFAULT 'trial' FOR status")
op.execute("ALTER TABLE tenants ADD CONSTRAINT df_tenants_max_users DEFAULT 5 FOR max_users")
op.execute("ALTER TABLE tenants ADD CONSTRAINT df_tenants_max_models DEFAULT 10 FOR max_models")
op.execute("ALTER TABLE tenants ADD CONSTRAINT df_tenants_max_scenarios DEFAULT 100 FOR max_scenarios_per_month")
op.execute("ALTER TABLE tenants ADD CONSTRAINT df_tenants_max_storage DEFAULT 1.0 FOR max_storage_gb")
```

---

## Troubleshooting

### Issue: "Cannot create more than one clustered index" Error
**Problem:** 
```
sqlalchemy.exc.ProgrammingError: Cannot create more than one clustered index on table 'tenants'. 
Drop the existing clustered index 'PK__tenants__...' before creating another.
```

**Solution:**
1. The migration file needs manual editing (see section 3.2 above)
2. Ensure `sa.PrimaryKeyConstraint('id', mssql_clustered=False)` is in the migration
3. This tells SQL Server to create a non-clustered primary key
4. Allows `index_id` to be the clustered index for optimal performance

**This is expected behavior** when using advanced SQL Server indexing with SQLAlchemy/Alembic.
```
